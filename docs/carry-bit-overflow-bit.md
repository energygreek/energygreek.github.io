---
date: 2024-04-12
tags: [c]
---

# 进位位和溢出位(carry bit/overflow bit)
这两个标志位是运算器(alu)的组成部分，因为运算器在执行加法时，要关注两个问题：是否进位超了；是否溢出了。这两个问题很相似，但有区别。

## 加法和减法
对于减法而言，实际是将减数翻转，然后执行加法。即：
```
1 - 1 = 1 + (-1)
```

运算器做减法时要比较两数的绝对值大小再进行减法，符号设置成大的数的符号，例如
```
2 - 1 => 2 - 1 = 1 => 符号位设置成2的符号位
1 - 2 => 2 - 1 = 1 => 符号位设置成1的符号位
```

数字在内存中存放的是“补码”形式，补码很多好处，对于正数而言，源码、反码、补码的二进制形式相同。补码统一了+0和-0的形式，而且补码适合做减法运算。
```
+0/-0
原码: 0000 0000/ 1000 0000
反码: 0000 0000/ 1111 1111 正数不变，负数的符号位不变，其它位取反
补码: 0000 0000/10000 0000 正数不变，负数先转反码再加1，进位位丢掉后相同
```

## 进位标志位
进位位用来标志两数相加产生的进位超过了位数，例如 1+1 = 10，要多一位，如果运算器是8位的，执行 11111111+1的运算，就要进位，且超过了位数，这时候进位位就会置1。

判断方法 **Carry = (Result >> n) & 1**

## 溢出标志位
溢出位只针对有符号数的运算，有符号数的第一位表示正负，0代表正，1代表负，其它位表示值。当值的部分想加产生进位时，导致符号位覆盖。

判断方法（就8位而言） **Overflow = (Result [7bit] XOR Op1[7bit] XOR Op2[7bit])**

溢出位置1时，虽然符号为不正确，但其值是正确的（包含符号位）。
## 参考
[源码/反码/补码](https://blog.csdn.net/weixin_44718794/article/details/106252940)
[进位位/溢出位](https://www.circuitsgallery.com/carry-bit-vs-overflow-bit/?utm_source=pocket_saves)